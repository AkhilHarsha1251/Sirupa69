IMPLEMENT CEASER CIPHER ENCRYPTION AND DECRYPTION:

def encrypt(text,s):
    result = ""
 
    for i in range(len(text)):
        char = text[i]
 
        if(char==' '):
            result += ' '
        elif (char.isupper()):
            result += chr((ord(char) + s-65) % 26 + 65)
        else:
            result += chr((ord(char) + s - 97) % 26 + 97)
 
    return result
 
def decrypt(text,s):
    result = ""
 
    for i in range(len(text)):
        char = text[i]
        
        if(char==' '):
            result += ' '
        elif (char.isupper()):
            result += chr((ord(char) - s - 65) % 26 + 65)
 
        else:
            result += chr((ord(char) - s - 97) % 26 + 97)
 
    return result


while(True):
 x = int(input("\n\nEnter\n0 for Exit: \n1 for Encrypt: \n2 for Decrypt: \n"))
 if x==0:
   break
 elif x==1:
   text = input("Text   : ")
   s = int(input("Shift  : "))
   print ("Encrypted Text: " + encrypt(text,s))
 elif x==2:
   text = input("Text   : ")
   s = int(input("Shift  : "))
   print ("Decrypted Text: " + decrypt(text,s))
 else:
   pass
___________________________________________________________________________________________________________________
IMPLEMENT PLAYFAIR CIPHER ENCRYPTION

def generate_key_square(key):
    key = key.upper().replace("J", "I")
    key_square = list(key)
    for char in "ABCDEFGHIKLMNOPQRSTUVWXYZ":
        if char not in key:
            key_square.append(char)
    key_square = [key_square[i:i+5] for i in range(0, 25, 5)]
    return key_square

def find_position(key_square, char):
    for i in range(5):
        for j in range(5):
            if key_square[i][j] == char:
                return i, j

def encrypt(plaintext, key):
    key_square = generate_key_square(key)
    print("Key Square:")
    for row in key_square:
        print(" ".join(row))

    ciphertext = ""
    for i in range(0, len(plaintext), 2):
        digraph = plaintext[i:i+2]
        if len(digraph) == 1:
            digraph += "X"
        row1, col1 = find_position(key_square, digraph[0])
        row2, col2 = find_position(key_square, digraph[1])

        if row1 == row2:
            ciphertext += key_square[row1][(col1+1)%5] + key_square[row2][(col2+1)%5]
        elif col1 == col2:
            ciphertext += key_square[(row1+1)%5][col1] + key_square[(row2+1)%5][col2]
        else:
            ciphertext += key_square[row1][col2] + key_square[row2][col1]

    return ciphertext

def decrypt(ciphertext, key):
    key_square = generate_key_square(key)
    plaintext = ""
    for i in range(0, len(ciphertext), 2):
        digraph = ciphertext[i:i+2]
        row1, col1 = find_position(key_square, digraph[0])
        row2, col2 = find_position(key_square, digraph[1])

        if row1 == row2:
            plaintext += key_square[row1][(col1-1)%5] + key_square[row2][(col2-1)%5]
        elif col1 == col2:
            plaintext += key_square[(row1-1)%5][col1] + key_square[(row2-1)%5][col2]
        else:
            plaintext += key_square[row1][col2] + key_square[row2][col1]

    return plaintext

while True:
    choice = input("Enter 1 for encryption, 2 for decryption, or any other key to exit: ")
   
    if choice == "1":
        key = input("Enter the key: ")
        key = key.upper()
        plaintext = input("Enter the plaintext: ")
        plaintext = plaintext.upper()
        ciphertext = encrypt(plaintext, key)
        print("Ciphertext:", ciphertext)

    elif choice == "2":
        key = input("Enter the key: ")
        key = key.upper()
        ciphertext = input("Enter the ciphertext: ")
        ciphertext = ciphertext.upper()
        plaintext = decrypt(ciphertext, key)
        print("Plaintext:", plaintext)

    else:
        break

___________________________________________________________________________________________________________________
IMPLEMENTING HILL CIPHER ENCRYPTION AND DECRYPTION:
 
import numpy as np
from sympy import Matrix

def encrypt(message, key):

    message = message.upper()
    key = key.upper()
    message = ''.join(i for i in message if i.isalpha())
    key = ''.join(i for i in key if i.isalpha())
    key_length = len(key)
    key_root = int(np.sqrt(key_length))
    if key_root ** 2 != key_length:
        print("Invalid key: not a square matrix")
        return
    message_vector = [ord(i) - 65 for i in message]
    key_vector = [ord(i) - 65 for i in key]
    key_matrix = Matrix(np.reshape(key_vector, (key_root, key_root)))
    if key_matrix.det() % 26 == 0:
        print("Invalid key: not invertible modulo 26")
        return
    message_length = len(message_vector)
    if message_length % key_root != 0:
        message_vector.extend([0] * (key_root - message_length % key_root))

    message_blocks = [message_vector[i:i + key_root] for i in range(0, message_length, key_root)]

    cipher_blocks = [key_matrix * Matrix(block) % 26 for block in message_blocks]

    cipher_vector = [i for block in cipher_blocks for i in block]

    cipher_text = ''.join(chr(i + 65) for i in cipher_vector)
    return cipher_text

def decrypt(cipher_text, key):

    cipher_text = cipher_text.upper()
    key = key.upper()

    cipher_text = ''.join(i for i in cipher_text if i.isalpha())
    key = ''.join(i for i in key if i.isalpha())

    key_length = len(key)
    key_root = int(np.sqrt(key_length))
    if key_root ** 2 != key_length:
        print("Invalid key: not a square matrix")
        return

    cipher_vector = [ord(i) - 65 for i in cipher_text]
    key_vector = [ord(i) - 65 for i in key]
    key_matrix = Matrix(np.reshape(key_vector, (key_root, key_root)))

    if key_matrix.det() % 26 == 0:
        print("Invalid key: not invertible modulo 26")
        return

    key_inverse = key_matrix.inv_mod(26)
    cipher_blocks = [cipher_vector[i:i + key_root] for i in range(0, len(cipher_vector), key_root)]

    message_blocks = [key_inverse * Matrix(block) % 26 for block in cipher_blocks]

    message_vector = [i for block in message_blocks for i in block]

    message_text = ''.join(chr(i + 65) for i in message_vector)
    return message_text
while True:

    choice = int(input("\nEnter 1 for Encryption OR 2 for Decryption: OR 3 for Exit: "))

    if choice == 1 :
        message = input("Enter the message: ")
        key = input("Enter the key: ")
        cipher_text = encrypt(message, key)
        print("The encrypted message is:", cipher_text)

    elif choice == 2 :
        message = input("Enter the message: ")
        key = input("Enter the key: ")
        message_text = decrypt(cipher_text, key)
        print("The decrypted message is:", message_text)

    elif choice == 3:
        break
    else:
        print("Invalid choice: please enter 1,2 OR 3")
        
___________________________________________________________________________________________________________________
IMPLEMENTATION OF EUCLIDEAN ALGORITHM

def extended_euclidean_alg(a, b):
    x = []
    y = []
    q_i = int(a/b)
    x.append(0)
    y.append(1)
    x.append(1)
    y.append(-q_i)
    a, b = b, a % b
    i = 2
    print(f'Initial setup: x[0]={x[0]}, y[0]={y[0]}, x[1]={x[1]}, y[1]={y[1]}, a={a}, b={b}')
    while (b > 0):
        r_i = a % b
        q_i = int(a/b)
        a, b = b, a % b
        x.append(x[i-2] - q_i * x[i-1])
        y.append(y[i-2] - q_i * y[i-1])
        print(f'Step {i}: x[{i}]={x[i]}, y[{i}]={y[i]}, a={a}, b={b}')
        i += 1
    print(f'Final result: gcd={a}, x={x[i-2]}, y={y[i-2]}')
    return (a, x[i-2], y[i-2])

if __name_=='__main__':
    print("Enter  values of a & b :")
    a = int(input())
    b = int(input())
    d, x, y = extended_euclidean_alg(a, b)
    print(f'{a}x{x} + {b}x{y} = {a*x + b*y} = gcd({a}, {b}) = {d}')
   
___________________________________________________________________________________________________________________
IMPLEMENTATION of DES algorithm

  def hex2bin(s):
	mp = {'0': "0000",
		'1': "0001",
		'2': "0010",
		'3': "0011",
		'4': "0100",
		'5': "0101",
		'6': "0110",
		'7': "0111",
		'8': "1000",
		'9': "1001",
		'A': "1010",
		'B': "1011",
		'C': "1100",
		'D': "1101",
		'E': "1110",
		'F': "1111"}
	bin = ""
	for i in range(len(s)):
		bin = bin + mp[s[i]]
	return bin

# Binary to hexadecimal conversion


def bin2hex(s):
	mp = {"0000": '0',
		"0001": '1',
		"0010": '2',
		"0011": '3',
		"0100": '4',
		"0101": '5',
		"0110": '6',
		"0111": '7',
		"1000": '8',
		"1001": '9',
		"1010": 'A',
		"1011": 'B',
		"1100": 'C',
		"1101": 'D',
		"1110": 'E',
		"1111": 'F'}
	hex = ""
	for i in range(0, len(s), 4):
		ch = ""
		ch = ch + s[i]
		ch = ch + s[i + 1]
		ch = ch + s[i + 2]
		ch = ch + s[i + 3]
		hex = hex + mp[ch]

	return hex

# Binary to decimal conversion


def bin2dec(binary):

	binary1 = binary
	decimal, i, n = 0, 0, 0
	while(binary != 0):
		dec = binary % 10
		decimal = decimal + dec * pow(2, i)
		binary = binary//10
		i += 1
	return decimal

# Decimal to binary conversion


def dec2bin(num):
	res = bin(num).replace("0b", "")
	if(len(res) % 4 != 0):
		div = len(res) / 4
		div = int(div)
		counter = (4 * (div + 1)) - len(res)
		for i in range(0, counter):
			res = '0' + res
	return res

# Permute function to rearrange the bits


def permute(k, arr, n):
	permutation = ""
	for i in range(0, n):
		permutation = permutation + k[arr[i] - 1]
	return permutation

# shifting the bits towards left by nth shifts


def shift_left(k, nth_shifts):
	s = ""
	for i in range(nth_shifts):
		for j in range(1, len(k)):
			s = s + k[j]
		s = s + k[0]
		k = s
		s = ""
	return k

# calculating xow of two strings of binary number a and b


def xor(a, b):
	ans = ""
	for i in range(len(a)):
		if a[i] == b[i]:
			ans = ans + "0"
		else:
			ans = ans + "1"
	return ans


# Table of Position of 64 bits at initial level: Initial Permutation Table
initial_perm = [58, 50, 42, 34, 26, 18, 10, 2,
				60, 52, 44, 36, 28, 20, 12, 4,
				62, 54, 46, 38, 30, 22, 14, 6,
				64, 56, 48, 40, 32, 24, 16, 8,
				57, 49, 41, 33, 25, 17, 9, 1,
				59, 51, 43, 35, 27, 19, 11, 3,
				61, 53, 45, 37, 29, 21, 13, 5,
				63, 55, 47, 39, 31, 23, 15, 7]

# Expansion D-box Table

exp_d = [32, 1, 2, 3, 4, 5, 4, 5,
		6, 7, 8, 9, 8, 9, 10, 11,
		12, 13, 12, 13, 14, 15, 16, 17,
		16, 17, 18, 19, 20, 21, 20, 21,
		22, 23, 24, 25, 24, 25, 26, 27,
		28, 29, 28, 29, 30, 31, 32, 1]

# Straight Permutation Table

per = [16, 7, 20, 21,
	29, 12, 28, 17,
	1, 15, 23, 26,
	5, 18, 31, 10,
	2, 8, 24, 14,
	32, 27, 3, 9,
	19, 13, 30, 6,
	22, 11, 4, 25]

# S-box Table

sbox = [[[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7],
		[0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8],
		[4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0],
		[15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13]],

		[[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10],
		[3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5],
		[0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15],
		[13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9]],

		[[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8],
		[13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1],
		[13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7],
		[1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12]],

		[[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15],
		[13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9],
		[10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4],
		[3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14]],

		[[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9],
		[14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6],
		[4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14],
		[11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3]],

		[[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11],
		[10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8],
		[9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6],
		[4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13]],

		[[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1],
		[13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6],
		[1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2],
		[6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12]],

		[[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7],
		[1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2],
		[7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8],
		[2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11]]]

# Final Permutation Table
final_perm = [40, 8, 48, 16, 56, 24, 64, 32,
			39, 7, 47, 15, 55, 23, 63, 31,
			38, 6, 46, 14, 54, 22, 62, 30,
			37, 5, 45, 13, 53, 21, 61, 29,
			36, 4, 44, 12, 52, 20, 60, 28,
			35, 3, 43, 11, 51, 19, 59, 27,
			34, 2, 42, 10, 50, 18, 58, 26,
			33, 1, 41, 9, 49, 17, 57, 25]


def encrypt(pt, rkb, rk):

	pt = hex2bin(pt)

	# Initial Permutation
	pt = permute(pt, initial_perm, 64)
	print("After initial permutation: ", bin2hex(pt))

	# Splitting
	left = pt[0:32]
	right = pt[32:64]
	for i in range(0, 16):
		# Expansion D-box: Expanding the 32 bits data into 48 bits
		right_expanded = permute(right, exp_d, 48)

		# XOR RoundKey[i] and right_expanded
		xor_x = xor(right_expanded, rkb[i])

		# S-boxex: substituting the value from s-box table by calculating row and column
		sbox_str = ""
		for j in range(0, 8):
			row = bin2dec(int(xor_x[j * 6] + xor_x[j * 6 + 5]))
			col = bin2dec(
				int(xor_x[j * 6 + 1] + xor_x[j * 6 + 2] + xor_x[j * 6 + 3] + xor_x[j * 6 + 4]))
			val = sbox[j][row][col]
			sbox_str = sbox_str + dec2bin(val)

		# Straight D-box: After substituting rearranging the bits
		sbox_str = permute(sbox_str, per, 32)

		# XOR left and sbox_str
		result = xor(left, sbox_str)
		left = result

		# Swapper
		if(i != 15):
			left, right = right, left
		#print("Round ", i + 1, " ", bin2hex(left)," ", bin2hex(right), " ", rk[i])

	# Combination
	combine = left + right

	# Final permutation: final rearranging of bits to get cipher text
	cipher_text = permute(combine, final_perm, 64)
	return cipher_text


while(1):
 xx = int(input("\n\n1 for Encrption, 2 for Decryption or 3 for Exit: "))
 if (xx==1):
   #pt  = "123456ABCD132536"
   pt  = input("\nEnter Plain Text: ")
   key = input("Enter Key       : ")
   #key = "AABB09182736CCDD"

 elif (xx==2):
   pt  = input("\nEnter Cipher Text: ")
   key = input("Enter Key        : ")
  
 elif (xx==3):
   break
 else:
   print("\nEnter Correct Choice: ")
   pass
 if(xx==1 or xx==2):
  # Key generation
  # --hex to binary
  key = hex2bin(key)

  # --parity bit drop table
  keyp = [57, 49, 41, 33, 25, 17, 9,
		1, 58, 50, 42, 34, 26, 18,
		10, 2, 59, 51, 43, 35, 27,
		19, 11, 3, 60, 52, 44, 36,
		63, 55, 47, 39, 31, 23, 15,
		7, 62, 54, 46, 38, 30, 22,
		14, 6, 61, 53, 45, 37, 29,
		21, 13, 5, 28, 20, 12, 4]

  # getting 56 bit key from 64 bit using the parity bits
  key = permute(key, keyp, 56)

  # Number of bit shifts
  shift_table = [1, 1, 2, 2,
			2, 2, 2, 2,
			1, 2, 2, 2,
			2, 2, 2, 1]

  # Key- Compression Table : Compression of key from 56 bits to 48 bits
  key_comp = [14, 17, 11, 24, 1, 5,
			3, 28, 15, 6, 21, 10,
			23, 19, 12, 4, 26, 8,
			16, 7, 27, 20, 13, 2,
			41, 52, 31, 37, 47, 55,
			30, 40, 51, 45, 33, 48,
			44, 49, 39, 56, 34, 53,
			46, 42, 50, 36, 29, 32]

  # Splitting
  left = key[0:28] # rkb for RoundKeys in binary
  right = key[28:56] # rk for RoundKeys in hexadecimal

  rkb = []
  rk = []
  for i in range(0, 16):
     # Shifting the bits by nth shifts by checking from shift table
     left = shift_left(left, shift_table[i])
     right = shift_left(right, shift_table[i])

     # Combination of left and right string
     combine_str = left + right

     # Compression of key from 56 to 48 bits
     round_key = permute(combine_str, key_comp, 48)

     rkb.append(round_key)
     rk.append(bin2hex(round_key))
 if (xx==1):
  print("\nEncryption")
  cipher_text = bin2hex(encrypt(pt, rkb, rk))
  print("Cipher Text : ", cipher_text)
 elif (xx==2):
  print("\nDecryption")
  rkb_rev = rkb[::-1]
  rk_rev = rk[::-1]
  text = bin2hex(encrypt(cipher_text, rkb_rev, rk_rev))
  print("Plain Text : ", text,end='\n\n')
 else:
   pass
___________________________________________________________________________________________________________________
IMPLEMENTATION OF RSA ALGORITHM

import math
 
def str_iarr(msg):
 return [ord(char) - ord('a')+1  if 'a' <= char <= 'z' else 0 if char == 'a' else 26 if char == 'z' else char for char in msg.lower()]

def iarr_str(iarr):
 return ''.join(chr(i + ord('a')-1) if 0 <= i <= 25 else chr(i + ord('A')-1) - 32 for i in iarr)

def gcd(a, h):
    temp = 0
    while(1):
        temp = a % h
        if (temp == 0):
            return h
        a = h
        h = temp
 
 
p = int(input("Enter p: "))
q = int(input("Enter q: "))
n = p*q
phi = (p-1)*(q-1)
print("phi = ",phi)


et = int(input("\nEnter '1' for Custom 'e' or else Random 'e' will be calculated: "))
if et!=1:
 e = 2
 while (e < phi):
 
    # e must be co-prime to phi and
    # smaller than phi.
    if(gcd(e, phi) == 1):
        break
    else:
        e = e+1
 print(f"Public_Key  <{e},{n}>")
else:
 e = int(input("Enter e: "))
 print(f"Public_Key  <{e},{n}>")

# Private key (d stands for decrypt)
# choosing d such that it satisfies
# d*e = 1 + k * totient


dt = int(input("\nEnter '1' for Custom 'd' or else 'd' will be calculated: "))
if dt!=1:
 for k in range(1,phi):
  z = (k*e)%phi
  #print(k,k*e,z)
  if z==1:
   d=k
   break
 d=math.ceil(d)
 print(f"Private_Key <{d},{n}>")
else:
 d = int(input("Enter d: "))
 print(f"Private_Key <{d},{n}>")
 

# Message to be encrypted
msg_type = int(input ("\nEnter '1' for Text_Type or else Int_Type will be taken:  "))
msg=[]

if msg_type==1:
 msg = input("Enter Msg(str)     : ")
 msg = str_iarr(msg)
 print("Converted_msg      :",msg)

else:
 msg2 = input("Enter Msg(int)     : ")
 msg2 = msg2.split(" ")
 for i in msg2:
   msg.append(int(i))



print('\nEncrypted data     : ',end='')
# Encryption c = (msg ^ e) % n
c =[]
cc=[]
for i in msg:
 a = i**e
 a = a%n
 c.append(a)
 print(a,end=" ")
for j in c:
 cc.append(j%26)

if msg_type==1:
 print("\nConverted_Encrypted:",iarr_str(cc))

msg3=[]
print('\nOriginal Message   : ',end='')
# Decryption m = (c ^ d) % n
for i in c:
 m = i**d
 m = m%n
 msg3.append(m)
 print(m,end=" ")
if msg_type==1:
 msg4=[]
 for j in msg3:
  msg4.append(j%26)
 print("\nConverted_Original :",iarr_str(msg4))

print("\n")

___________________________________________________________________________________________________________________
IMPLEMENTATION of Man in The Middle Attack with Diffie-Hellman Key Exchange:

import random
 
# public keys are taken
# p is a prime number
# g is a primitive root of p
p = int(input('\nEnter a prime number : '))
g = int(input('Enter a number : '))
 
 
class A:

    def __init__(self):
        # Generating a random private number selected by alice
        self.n = random.randint(1, p)     
 
    def publish(self):
        # generating public values
        return (g**self.n)%p
 
    def compute_secret(self, gb):
        # computing secret key
        return (gb**self.n)%p
 
 



class B:

    def __init__(self):
        # Generating a random private number selected for alice
        self.a = random.randint(1, p)
        # Generating a random private number selected for bob
        self.b = random.randint(1, p)
        self.arr = [self.a,self.b]
 
    def publish(self, i):
        # generating public values
        return (g**self.arr[i])%p
 
    def compute_secret(self, ga, i):
        # computing secret key
        return (ga**self.arr[i])%p
 
 
alice = A()
bob = A()
eve = B()
 
# Printing out the private selected number by Alice and Bob

print(f'\nAlice selected (Xa) : {alice.n}')
print(f'Bob selected (Xb) : {bob.n}')
print(f'\nEve selected private number for Alice (Xd1) : {eve.a}')
print(f'Eve selected private number for Bob (Xd2) : {eve.b}\n')
 
# Generating public values 

ga = alice.publish()
gb = bob.publish()
gea = eve.publish(0)
geb = eve.publish(1)
print(f'Alice published (Ya): {ga}')
print(f'Bob published (Yb): {gb}')
print(f'\nEve published value for Alice (Yd1): {gea}')
print(f'Eve published value for Bob (Yd2): {geb}\n')
 
# Computing the secret key

sa = alice.compute_secret(gea)
sea = eve.compute_secret(ga,0)
sb = bob.compute_secret(geb)
seb = eve.compute_secret(gb,1)

print(f'Alice computed (K1) : {sa}')
print(f'Eve computed key for Alice (K_Alice) : {sea}\n')
print(f'Bob computed (K2) : {sb}')
print(f'Eve computed key for Bob (K_Bob) : {seb}\n')	
___________________________________________________________________________________________________________________
IMPLEMENTATION of ElGamal Encryption and Decryption:

import random 
from math import pow

a = random.randint(2, 10)

def gcd(a, b):
	if a < b:
		return gcd(b, a)
	elif a % b == 0:
		return b;
	else:
		return gcd(b, a % b)

# Generating large random numbers
def gen_key(q):

	key = random.randint(pow(10, 20), q)
	while gcd(q, key) != 1:
		key = random.randint(pow(10, 20), q)

	return key

# Modular exponentiation
def power(a, b, c):
	x = 1
	y = a

	while b > 0:
		if b % 2 != 0:
			x = (x * y) % c;
		y = (y * y) % c
		b = int(b / 2)

	return x % c

# Asymmetric encryption
def encrypt(msg, q, h, g):

	en_msg = []

	k = gen_key(q)# Private key for sender
	s = power(h, k, q)
	p = power(g, k, q)
	
	for i in range(0, len(msg)):
		en_msg.append(msg[i])

          print("g^k used : ", p)
	print("g^ak used : ", s)

	for i in range(0, len(en_msg)):
		en_msg[i] = s * ord(en_msg[i])

	return en_msg, p


def decrypt(en_msg, p, key, q):

	dr_msg = []
	h = power(p, key, q)
	for i in range(0, len(en_msg)):
		dr_msg.append(chr(int(en_msg[i]/h)))
		
	return dr_msg


def main():

	msg = input("Enter the message to encrypt: ")
	print("Original Message :", msg)

	q = random.randint(pow(10, 20), pow(10, 50))
	g = random.randint(2, q)

	key = gen_key(q)# Private key for receiver
	h = power(g, key, q)
	print("g used : ", g)
	print("g^a used : ", h)

	en_msg, p = encrypt(msg, q, h, g)
	dr_msg = decrypt(en_msg, p, key, q)
	dmsg = ''.join(dr_msg)
	print("Decrypted Message :", dmsg);


if __name__ == '__main__':
	main()
 
___________________________________________________________________________________________________________________
DIGITAL SIGNATURE STANADARD IMPLEMENTATION

import random
import hashlib
import sys

# Helper functions for modular exponentiation and modular inverse
def mod_exp(base, exponent, modulus):
    result = 1
    while exponent > 0:
        if exponent % 2 == 1:
            result = (result * base) % modulus
        base = (base * base) % modulus
        exponent = exponent // 2
    return result

def egcd(a, b):
    x0, x1, y0, y1 = 1, 0, 0, 1
    while b != 0:
        q, a, b = a // b, b, a % b
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    return a, x0, y0

def mod_inv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('Modular inverse does not exist')
    else:
        return x % m

# RSA key generation
def generate_keypair(bits):
    def is_prime(n, k=5):
        if n <= 1:
            return False
        if n <= 3:
            return True
        if n % 2 == 0:
            return False

        r = 0
        s = n - 1
        while s % 2 == 0:
            r += 1
            s //= 2

        for _ in range(k):
            a = random.randrange(2, n - 1)
            x = pow(a, s, n)
            if x == 1 or x == n - 1:
                continue
            for _ in range(r - 1):
                x = pow(x, 2, n)
                if x == n - 1:
                    break
            else:
                return False
        return True

    def generate_prime(bits):
        while True:
            num = random.getrandbits(bits)
            if is_prime(num):
                return num

    p = generate_prime(bits)
    q = generate_prime(bits)

    n = p * q
    phi = (p - 1) * (q - 1)

    while True:
        e = random.randrange(2, phi)
        if egcd(e, phi)[0] == 1:
            break

    d = mod_inv(e, phi)

    return ((n, e), (n, d))

# Signature generation and verification
def sign(message, private_key):
    n, d = private_key
    hashed_message = int.from_bytes(hashlib.sha256(message.encode()).digest(), byteorder='big')
    signature = mod_exp(hashed_message, d, n)
    return signature

def verify(message, signature, public_key):
    n, e = public_key
    hashed_message = int.from_bytes(hashlib.sha256(message.encode()).digest(), byteorder='big')
    decrypted_signature = mod_exp(signature, e, n)
    return hashed_message == decrypted_signature

# Example usage
message = input("Enter the message  :")
private_key, public_key = generate_keypair(1024)
signature = sign(message, private_key)
print("Message:", message)
print("Signature:", signature)
print("Verification:", verify(message, signature, public_key))
    
___________________________________________________________________________________________________________________
To explore different features of the software WireShark which is used for tracing packet on a particular interface.

1)Capture the packets using Wireshark and depict the TCP connection establishment and termination process.

PROCEDURE:

a.Open the capture menu and select the interface which is currently 
   connected.
b.Now select the promiscuous monitoring option to monitor all the   
   packets coming to the interface.
c.Now click the start option on the left bottom of dialog box.
d.It will start capturing the packets
e.Stop the capturing of the packets.
f.Now type tcp in the display filter and press enter.

Capturing the Ethernet packets using promiscuous monitoring:

Filtering the TCP connections out of all the packets received:
 

2)Filter the TCP packets that contain the request to terminate.

PROCEDURE:


a.For Filtering the tcp packets that contain the request to terminate we 
   have to choose fin packets which stands for finished.
b.So to filter out the packets which contains request to terminate type 
   tcp.connection.fin in the display filter and press enter.



3)Depict the flowgraph and the I/O graph of TCP, UDP, ICMP, and ARP.

PROCEDURE:

a.Go to Statistics menu and select the Flowgraph option.
b.A dialog box wil appear
c.Select All Flows in the Flow Type option
d.Observe the graph pattern and close the dialog box.

Flowgraph of TCP, UDP and ARP:
 
PROCEDURE:

a.Enter all the name of the packets you want to plot graph off.
b.In this case tcp or udp or arp or icmp
c.Go to Statistics menu and select the I/O Graph option.
d.A dialog box will appear select the Filtered packets option.
e.Observe the graph pattern and close the dialog box.

I/O Graph of TCP, ARP, UDP and ICMP:

RESULTS:
Hence, we explored different features of WireShark and analysed the captured packets successfully.
___________________________________________________________________________________________________________________
JSON Web Token

Aim: : Develop a web application that implements JSON web token.

Procedure :
Backend Setup (Choose one based on your preferred framework):
1.	Project Setup: Create a new project in your chosen backend framework (e.g., Node.js with Express, Python with Flask, etc.).
2.	Dependency Management: Install necessary libraries for working with JWTs. Popular options include jsonwebtoken (Node.js) or PyJWT (Python).
User Management:
3.	User Database: Implement a user database to store user credentials (username, password) securely. This can be a relational database (MySQL, PostgreSQL) or a NoSQL database (MongoDB).
4.	User Registration: Develop an API endpoint for user registration where new users can sign up with their credentials. Hash passwords securely before storing them (e.g., using bcrypt).
Authentication with JWT:
5.	Login Endpoint: Create an API endpoint for user login. Users will provide their credentials for authentication.
 
6.	User Verification: Verify the username and password against the user database.
7.	Payload Creation: If login is successful, generate a JWT payload containing user information (e.g., user ID, username).
8.	Secret Key Setup: Define a strong, secret key for signing and verifying JWTs. Store this key securely (environment variables recommended).
9.	Token Signing: Use the JWT library and the secret key to sign the payload, creating the JWT token.
Token Management:
a.	Token Distribution: Send the generated JWT token back to the client-side application (typically in the response body or header).
Client-Side Integration:
b.	JWT Storage: Securely store the received JWT token on the client-side (e.g., browser local storage with appropriate security measures like HttpOnly flag).
Secured API Endpoints:
c.	iddleware Implementation: Develop middleware in your backend framework to validate JWTs before accessing protected API endpoints.
d.	Token Extraction: Extract the JWT token from the request headers (commonly sent in the "Authorization" header with a "Bearer" prefix).
e.	Token Verification: Use the JWT library and the secret key to verify the signature and integrity of the received JWT.
f.	User Authorization: If the token is valid, extract user information from the payload and use it for authorization checks to determine user access to specific resources.
 
Outputs :
Token Generation :


"name": "harsha", "email":"akhilharsha78@gmail.com", "password":"harsha123", "picturePath":"test.jpg"
"name": "harsha",
"email": "akhilharsha78@gmail.com", "password": "$2b$10$vL8rvj
.XfGXDZXPdy864LukybTMDMfSCPXL6RU6Mn4ryjx3fGFeJK", "picturePath": "test.jpg",
"_id": "662a3544529e0c543b1d6c4b", "createdAt": "2024-04-25T10:49:40.870Z", "updatedAt": "2024-04-25T10:49:40.870Z",

Cookie Stored in Database Successfully:
 
Login Successful:

Cookie Saved the JSON web token:
 
Task Creation:

Task stored stored in the data base:
___________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________

